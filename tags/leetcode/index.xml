<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>leetcode on ccq&#39;s blog</title>
    <link>https://ccqstark.github.io/tags/leetcode/</link>
    <description>Recent content in leetcode on ccq&#39;s blog</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 04 Apr 2021 21:07:00 +0800</lastBuildDate><atom:link href="https://ccqstark.github.io/tags/leetcode/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>[leetcode]209.长度最小的子数组</title>
      <link>https://ccqstark.github.io/p/min_sub_array_len/</link>
      <pubDate>Sun, 04 Apr 2021 21:07:00 +0800</pubDate>
      
      <guid>https://ccqstark.github.io/p/min_sub_array_len/</guid>
      <description>题目 给定一个含有 n 个正整数的数组和一个正整数 target 。
找出该数组中满足其和 ≥ target 的长度最小的 连续子数组 [numsl, numsl+1, &amp;hellip;, numsr-1, numsr] ，并返回其长度。如果不存在符合条件的子数组，返回 0 。
示例 1: 输入: target = 7, nums = [2,3,1,2,4,3] 输出: 2 解释: 子数组 [4,3] 是该条件下的长度最小的子数组. 示例 2: 输入: target = 4, nums = [1,4,4] 输出: 1 示例 3: 输入: target = 11, nums = [1,1,1,1,1,1,1,1] 输出: 0 提示：
 1 &amp;lt;= target &amp;lt;= 109 1 &amp;lt;= nums.length &amp;lt;= 105 1 &amp;lt;= nums[i] &amp;lt;= 105  分析 这道题一开始想到的是暴力解法，也就是把每种可能的子数组长度都试一遍，后来发现这是道典型的滑动窗口题目，用滑动窗口就解决了。之后看官方题解有前缀+二分搜索的方法作为扩展。</description>
    </item>
    
    <item>
      <title>[leetcode]27.移除元素</title>
      <link>https://ccqstark.github.io/p/remove_element/</link>
      <pubDate>Fri, 02 Apr 2021 21:07:00 +0800</pubDate>
      
      <guid>https://ccqstark.github.io/p/remove_element/</guid>
      <description>题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
分析 对于数组而言，我们原地移除元素的话就肯定要把被移除的元素后面的全部元素都往前挪一个位，这是最基本的操作。所以最普通的暴力解法就是删除一个，整体挪动一个位。优化一点的话就是当有几个需要删除的数连在一起时，我们找到边界后一起挪动n个位，减少整体挪动的次数。
最优的是经常被用到的双指针法，下面再解释。
代码 混合暴力法 public int removeElement(int[] nums, int val) { int len = nums.length; for (int left = 0; left &amp;lt; len; left++) { if (nums[left] == val) { // left位于最后一个元素时  if (left == len - 1) { return len - 1; } int right = left + 1; while (right &amp;lt;= len - 1 &amp;amp;&amp;amp; nums[right] == val) right++; if (right == len - 1 &amp;amp;&amp;amp; nums[right] == val) { // right超过长度时  return len - (right - left); } // 把元素right处整体前移到left  moveUp(left, right, nums, len); len = len - (right - left); } } return len; } // 该函数用于将right及后面的元素完前移到left位置 public void moveUp(int left, int right, int[] nums, int len) { int step = len - 1 - right; for (int i = 0; i &amp;lt;= step; i++) { nums[left + i] = nums[right + i]; } } 此方法其实是初步优化的暴力法，假设我们要移除值为2的元素，left指针找到第一被删除的元素，right指向left后第一个不等于2的元素，然后把从right开始的后面全部元素都往前挪至left位置。</description>
    </item>
    
    <item>
      <title>[leetcode]35.搜索插入位置</title>
      <link>https://ccqstark.github.io/p/search_insert/</link>
      <pubDate>Thu, 01 Apr 2021 21:07:00 +0800</pubDate>
      
      <guid>https://ccqstark.github.io/p/search_insert/</guid>
      <description>题目 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
你可以假设数组中无重复元素。
示例 1: 输入: [1,3,5,6], 5 输出: 2 示例 2: 输入: [1,3,5,6], 2 输出: 1 示例 3: 输入: [1,3,5,6], 7 输出: 4 示例 4: 输入: [1,3,5,6], 0 输出: 0 分析 这道题就是找到数组中的数，遍历就不说了， 我们首先想到的比较好的解法当然是二分搜索
需要注意的是当目标值不存在于数组中时，我们要如何去定位合适的插入点？先上代码再分析。
代码 public int searchInsert(int[] nums, int target) { return binSearch(0,nums.length-1,target,nums); } public int binSearch(int left, int right, int x, int[] nums) { if (left &amp;gt; right) return left; int mid = (left + right) / 2; if (x &amp;lt; nums[mid]) return binSearch(left, mid - 1, x, nums); if (x &amp;gt; nums[mid]) return binSearch(mid + 1, right, x, nums); if (x == nums[mid]) return mid; return -1; } 这里是采用传统的递归来写二分，但其实这里可以不用，直接一个while循环就行</description>
    </item>
    
    <item>
      <title>[leetcode]1.两数之和</title>
      <link>https://ccqstark.github.io/p/two_sum/</link>
      <pubDate>Wed, 31 Mar 2021 21:07:00 +0800</pubDate>
      
      <guid>https://ccqstark.github.io/p/two_sum/</guid>
      <description>题目 给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 的那 两个 整数，并返回它们的数组下标。
你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。
你可以按任意顺序返回答案。
示例 1: 输入: nums = [2,7,11,15], target = 9 输出: [0,1] 解释: 因为 nums[0] + nums[1] == 9, 返回 [0, 1]. 示例 2: 输入: nums = [3,2,4], target = 6 输出: [1,2] 示例 3: 输入: nums = [3,3], target = 6 输出: [0,1] 提示：
 2 &amp;lt;= nums.length &amp;lt;= 103 -109 &amp;lt;= nums[i] &amp;lt;= 109 -109 &amp;lt;= target &amp;lt;= 109 只会存在一个有效答案  分析 这道题比较容易，就是在数组中找到数值x和target-x</description>
    </item>
    
  </channel>
</rss>
